# Rust 学习 - 02

## 第3章：Common Programming Concepts

这一章就介绍了Rust中的一些和其他语言一样的特性在Rust中是如何表现的。

在本书的[附录A](https://doc.rust-lang.org/book/appendix-01-keywords.html)中包含Rust使用的所有关键字。



---

### 1. 变量

#### 1. 变量与可变性

Rust的变量是默认不可变的，但也能选择让变量可变，这一节会说明不可变的好处以及何时应该让它可变。

如果试图给一个不可变的变量重新赋值：

```rust
fn main() {
    let x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
```

就会得到一个编译器报错：`cannot assign twice to immutable variable`

在一个不可变的变量被试图改变时报错，可以避免程序的一些Bug。比如在代码段A中假设变量的不变的，但在代码段B中却改变了这个变量，这就可能导致代码段A出现BUG，这样的Bug很难被追踪，尤其是在代码段B只是有时会改变这个变量时。



#### 2. 变量和常量的区别

不可变的变量与常量非常像，但是二者是不同的：常量永远是不可变的，而变量仅仅是默认不可变。

1. 使用`const`关键字来声明一个常量，同时必须声明常量的类型；
2. 常量可以在任何地方被声明；
3. Rust的常量命名风格是：全大写，用下划线分割单词`const MAX_POINTS: u32 = 100_000;`，同时数字可以用下划线分割来提高可读性；
4. 常量的声明周期是整个代码块。



#### 3. Shadowing

可以对一个已经声明的immutable变量修改内容。

```rust
let x = 5;
let x = x + 1;
let x = x * 3;
```

`Shadowing`可以重复使用一个变量名，同时改变这个变量的类型，这一点比`mut`更好，因为`mut`在需要同一个变量的不同变量类型的时候必须重新声明一个。



---

### 2. 数据类型

Rust中每一个变量都有一个确定的类型（强类型语言），这里我们将主要看两种数据类型集。Scalar和Compound。

同时Rust还是静态类型语言，也就是数据的类型必须要编译期就被确定。所以在做类型转换时，必须告诉编译器要转换的目标类型。



#### 1. Scalar Types

`Scalar`类型表示了一个单值，Rust有四种`Scalar`类型：`integers` `floating-point numbers` `Booleans` `characters`。



##### 1. Integers

整型，Rust里面有以下这些整型：

| Length  | Signed | Unsigned |
| ------- | ------ | -------- |
| 8-bit   | i8     | u8       |
| 16-bit  | i16    | u16      |
| 32-bit  | i32    | u32      |
| 64-bit  | i64    | u64      |
| 128-bit | i128   | u128     |
| arch    | isize  | usize    |

n位有符号整数的表示范围是：\[ -2^n-1^, 2^n-1^ - 1 \]

n位无符号整数的表示范围是：[ 0, 2^n^ - 1 ]

`isize`和`usize`类型的长度由程序所运行的计算机架构决定，32位计算机即i32，64位就是i64

| Number literals  | Example     |
| ---------------- | ----------- |
| Decimal          | 98_222      |
| Hex              | 0xff        |
| Octal            | 0o77        |
| Binary           | 0b1111_0000 |
| Byte (`u8` only) | b'A'        |

Rust会处理整数溢出，当程序在Debug模式编译并在运行时出现整数溢出时，会导致程序`panic`。当程序编译时使用了`--release`选项，Rust就不会再检查整数溢出，而是会将溢出的部分截断。比如u8类型存储了257，溢出后变为1。（Wrapping）

Rust可以显式地处理溢出：

- 使用`wrapping_*`方法；
- 使用`checked_*`方法， 如果没有溢出，将返回`None`；
- 使用`overflowing_*`方法，将返回值以及一个Boolean来表示是否溢出；
- 使用`saturating_*`方法，将不进行wrapping，而是返回数据类型的最大、最小值。



##### 2. Floating-Point

Rust有两种浮点数：f32, f64。默认类型是f64，因为现代CPU在计算32位和64位浮点数时效率是一样的。



##### 3. 数字处理

Rust支持对数字类型的基本计算操作（加减乘除求余）。

```rust
fn main() {
    // addition
    let sum = 5 + 10;

    // subtraction
    let difference = 95.5 - 4.3;

    // multiplication
    let product = 4 * 30;

    // division
    let quotient = 56.7 / 32.2;

    // remainder
    let remainder = 43 % 5;
}
```



##### 4. Boolean

俩值：`true` `false`和C++一样是全小写。

```rust
fn main() {
    let t = true;

    let f: bool = false; // with explicit type annotation
}
```



##### 5. Character

Rust的字符类型使用单引号，字符串使用双引号。

```rust
fn main() {
    let c = 'z';
    let z = 'ℤ';
    let heart_eyed_cat = '😻';
}

```

Rust的字符长度是4个字节，并且使用Unicode编码，这意味这可以使用比ASCII更多的字符。

[第8章](https://doc.rust-lang.org/book/ch08-02-strings.html#storing-utf-8-encoded-text-with-strings)还会详细讨论Rust中的字符串。



#### 2. Compound Types（组合类型）

Rust有两种基本组合类型：tuples和arrays



##### 1. Tuple 元组

tuple可以将一些不同类型（或同一类型）的变量组合进一个组合类型。tuple有固定长度，在声明时确定，不可以增减。tuple中的元素用逗号分隔开，并用小括号包裹。

tuple的声明如下，类型可以不一致：

```rust
fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}

```

用以下的方法可以destructure一个tuple

```rust
fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("The value of y is: {}", y);
}
```

上面的这种方法把一个tuple变成了若干个单个变量，称为`destructuring`。

除了destructuring，还可以通过`.`访问tuple中的元素：

```rust
fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}

```

第一个元素的下标是0



##### 2. Array 数组

数组中的元素必须都是同一种类型。Rust中的数组和某些语言中不太一样，它也是和元组一样固定长度。

数组中的元素用逗号分隔，并用中括号包裹。

````rust
fn main() {
    let a = [1, 2, 3, 4, 5];
}

````

如果你想把数据存储在栈上而不是堆上时，应该使用数组。第4章会仔细讨论栈和堆。

Array没有vector灵活，vector可以变长变短，在标准库中提供。如果你不确定该使用Array或Vector，那么你大概需要vector。第8章会仔细讨论vector。

当你想要存储一些一定固定不变的数据时（一年12个月的名称），可以使用Array。

```rust
let a: [i32; 5] = [1, 2, 3, 4, 5];
```

在中括号中指定Array的类型已经元素个数。

如果想用相同的值初始化一个Array，可以使用下面的表达式：

```rust
let a = [3; 5];
```

这个表达式会创建一个有5个元素的数组，每个元素的值都是3。

可以使用下标访问数组元素。

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}

```

如果数组访问出现越界，会报错：`index out of bounds`，同时程序会panic。

```rust
use std::io;

fn main() {
    let a = [1, 2, 3, 4, 5];

    println!("Please enter an array index.");

    let mut index = String::new();

    io::stdin()
        .read_line(&mut index)
        .expect("Failed to read line");

    let index: usize = index
        .trim()
        .parse()
        .expect("Index entered was not a number");

    let element = a[index];

    println!(
        "The value of the element at index {} is: {}",
        index, element
    );
}

```



这是Rust的安全原则，保证了数组不能越界访问。

https://doc.rust-lang.org/book/ch03-03-how-functions-work.html