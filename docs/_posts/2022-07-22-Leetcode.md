---
layout:	post
title:	LeetCode Record
date:   2022-07-22 10:21:00 +0800
categories: note
---

<head>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    </script>
</head>
# LeetCode刷题记录

> 2022年7月29日

![image-20220730000321249]({{ site.url }}\imgs\leetcode\160.png)

最简单的方法：哈希表，遍历第一个链表，把地址都存入哈希表，然后再遍历第二个链表时查询哈希表。时间复杂度 $O(m+n)$ ，空间复杂度 $O(m)$。

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        unordered_set<ListNode*> nodes;
        ListNode *iter = headA;

        while (iter) {
            nodes.insert(iter);
            iter = iter->next;
        }
        iter = headB;
        while (iter) {
            if (nodes.find(iter) != nodes.end()) {
                return iter;
            }
            iter = iter->next;
        }
        return nullptr;
    }
};
```

题解上的一个非常妙的方法：

双指针，用两个指针分别遍历两个链表，然后：

- 如果两个指针地址相同，返回地址；
- 如果两个指针同时为空，返回`nullptr`；
- 如果A指针为空，B指针不为空，则将A指向B链表的起始节点；
- 如果B指针为空，A指针不为空，则将B指向A链表的起始节点；

正确性证明：

假设链表A到达相交点前有`a`个节点，链表B到达相交点前有`b`个节点，两链表相交的节点个数为`c`，则在双指针都到达相交点时遍历的节点数量相同，为`a+b+c`

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        if (!headA || !headB) return nullptr;
        if (headA == headB) return headA;
        ListNode* pa = headA;
        ListNode* pb = headB;
        while (pa != pb) {
            pa = pa ? pa->next : headB;
            pb = pb ? pb->next : headA;
        }
        return pa;
    }
};
```

> 2022年7月26日

![image-20220726191138265]({{ site.url }}\imgs\leetcode\108.png)

数据结构知识：

- 二叉搜索树：对于一棵二叉树，如果它的任意一个节点的左子树的所有节点的值都小于这个节点的值，且右子树的所有节点的值都大于这个节点的值，即为一棵二叉搜索树；
  - 二叉搜索树的中序遍历就是一个升序数列；
- 平衡二叉树：对于一颗二叉树，如果它的任意一个节点的左子树和右子树的深度之差小于2，则这棵树是一棵平衡二叉树；
  - 由数组构造平衡二叉树：逐个读取数组，并将下一个数字插入到当前树中，如果插入后的二叉树不平衡，则通过旋转将其变为平衡二叉树。（本题不需要）

本题根据二叉搜索树，即可确定做法：每次把数组的中间元素作为二叉树的根节点，即可建一棵平衡搜索树。

```c++
class Solution {
public:
    TreeNode* BuildTree(vector<int>& nums, int start, int end) {
        if (start >= end) return nullptr;
        int mid = start + (end - start) / 2;
        TreeNode* root = new TreeNode(nums[mid]);
        root->left = BuildTree(nums, start, mid);
        root->right = BuildTree(nums, mid + 1, end);
        return root;
    }

    TreeNode* sortedArrayToBST(vector<int>& nums) {
        return BuildTree(nums, 0, nums.size());
    }
};
```

> 2022年7月24日

![image-20220724231004899]({{ site.url }}\imgs\leetcode\101.png)

递归比较简单，从根节点分成两个子树，然后递归地比较两子树的左右子树是否相等即可：

```c++
class Solution {
public:
    bool CompareTwoTrees(TreeNode* tr1, TreeNode* tr2) {
        if (nullptr == tr1 && nullptr == tr2) return true;
        if (nullptr == tr1 || nullptr == tr2) return false;
        return (tr1->val == tr2->val) && CompareTwoTrees(tr1->left, tr2->right) && CompareTwoTrees(tr1->right, tr2->left);
    }

    bool isSymmetric(TreeNode* root) {
        if (nullptr == root->right && nullptr == root->left) return true;
        if (nullptr == root->right || nullptr == root->left) return false;
        TreeNode *left_half = root->left;
        TreeNode *right_half = root->right;
        return CompareTwoTrees(left_half, right_half);
    }
};
```

记录一个不太习惯的迭代法，其实就是用循环代替了递归，在每次循环开始进行递归要做的根节点比较，再在循环结束时利用**队列**准备好下次循环需要的数据：

```c++
class Solution {
public:
    bool CompareTwoTrees(TreeNode* tr1, TreeNode* tr2) {
        queue<TreeNode*> q;
        q.push(tr1);
        q.push(tr2);
        while (!q.empty()) {
            auto p1 = q.front();
            q.pop();
            auto p2 = q.front();
            q.pop();
            if (nullptr == p1 && nullptr == p2) continue;
            if (nullptr == p1 || nullptr == p2) return false;
            if (p1->val != p2->val) return false;

            q.push(p1->left);
            q.push(p2->right);
            q.push(p1->right);
            q.push(p2->left);
        }
        return true;
    }

    bool isSymmetric(TreeNode* root) {
        if (nullptr == root->right && nullptr == root->left) return true;
        if (nullptr == root->right || nullptr == root->left) return false;
        TreeNode *left_half = root->left;
        TreeNode *right_half = root->right;
        return CompareTwoTrees(left_half, right_half);
    }
};
```

> 2022年7月22日

![]({{ site.url }}\imgs\leetcode\69.png)

牛顿迭代法求解以下方程的根：
$$
f(x)=x^2-C
$$
迭代式为：
$$
x_{n+1} = x_{n}-\frac{f(x_n)}{f^{'}(x_n)} = x_n-\frac{x_n^2-C}{2x_n}=\frac{x_n+\frac{C}{x_n}}{2}
$$

```c++
class Solution {
public:
    int mySqrt(int x) {
        if (x == 0) return 0;
        if (x == 1) return 1;
        long long a = x;
        while (a > x / a) {
            a = (a + x / a) / 2;
        }
        return a;
    }
};
```







