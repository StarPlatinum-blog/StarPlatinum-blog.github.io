---
layout:	post
title:	LeetCode Record
date:   2022-07-22 10:21:00 +0800
categories: note
---

<head>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    </script>
</head>
# LeetCode刷题记录

>2023年2月21日

![image-20220823233042828]({{ site.url }}/imgs/leetcode/238.png)

评论区大神极其巧妙的解法：

在一次迭代的时候同时更新数组的前后元素

- 将前面元素左侧的乘积累乘到元素上；
- 将后面元素右侧的乘积累乘到元素上；

每个元素最终都会累乘到自己前后的元素，非常的巧妙。

```c++
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int n_len = nums.size();
        vector<int> ret(n_len, 1);
        int left = 1, right = 1;
        for (int i = 0; i < n_len; ++i) {
            ret[i] *= left;
            left *= nums[i];

            ret[n_len - i - 1] *= right;
            right *= nums[n_len - i - 1];
        }
        return ret;
    }
};
```

>2023年2月21日

![image-20220823233042828]({{ site.url }}/imgs/leetcode/jz09.png)

一道超简单的题目，下次要秒AC！

思路：

- 一个栈用于输入，另一个用输出；
- 入队非常简单，只需要直接push进输入栈即可；
- 出栈时，做以下判断：
  1. 输入栈、输出栈都为空，则直接返回-1；
  2. 输出栈不为空，则返回输出栈的栈顶元素；
  3. 输出栈为空，则逐个将输入栈中的元素pop出来，并push进输出栈，输入栈空后，返回输出栈的栈顶元素；

>2023年2月21日

![image-20220823233042828]({{ site.url }}/imgs/leetcode/33.png)

动态规划：确定状态！

```c++
// Trie树模板
class TrieNode {
    bool is_end;
    TrieNode* next[26];
public:
    TrieNode(): is_end(false) {
        memset(next, 0, sizeof(TrieNode*) * 26);
    }

    inline void AddCh(char ch) {
        next[ch - 'a'] = new TrieNode();
    }

    inline bool HasCh(char ch) {
        return next[ch - 'a'] != nullptr;
    }

    inline TrieNode* GetNext(char ch) {
        return next[ch - 'a'];
    }

    inline void SetEnd() {
        is_end = true;
    }

    inline bool IsEnd() {
        return is_end;
    }
};

class TrieTree {
private:
    TrieNode* head;
public:
    TrieTree() {
        head = new TrieNode();
    }
    void AddWord(const string& w) {
        int w_len = w.size();
        int idx = 0;
        TrieNode* cur = head;
        for (int i = 0; i < w_len; ++i) {
            if (!cur->HasCh(w[i])) {
                cur->AddCh(w[i]);
            }
            cur = cur->GetNext(w[i]);
            if (i == w_len - 1) {
                cur->SetEnd();
            }
        }
    }

    bool HasWord(const string& w) {
        TrieNode* cur = head;
        function<bool(int)> find_w = [&] (int i) -> bool {
            if (i >= w.size()) return cur->IsEnd();
            if (cur->GetNext(w[i])) {
                cur = cur->GetNext(w[i]);
                return find_w(i + 1);
            } else {
                return false;
            }
        };
        return find_w(0);
    }

    friend ostream& operator<<(ostream& os, const TrieTree& tree) {
        TrieNode* cur = tree.head;
        function<void(TrieNode*)> print_tree = [&] (TrieNode* node) {
            if (node->IsEnd()) {
                os << endl;
            }
            for (int i = 0; i < 26; ++i) {
                char w = static_cast<char>(i + 'a');
                if (node->GetNext(w)) {
                    os << w;
                    print_tree(node->GetNext(w));
                }
            }
        };
        print_tree(cur);
        return os;
    }
};
```



> 2023年2月17日

回溯法去重：上一次枚举的目标不要重复枚举

> 2023年2月17日

`lower_bound`和`upper_bound`的实现：

```c++
template <class ForwardIterator, class T>
  ForwardIterator lower_bound (ForwardIterator first, ForwardIterator last, const T& val)
{
  ForwardIterator it;
  iterator_traits<ForwardIterator>::difference_type count, step;
  count = distance(first,last);
  while (count>0)
  {
    it = first; step=count/2; advance (it,step);
    if (*it<val) {                 // or: if (comp(*it,val)), for version (2)
      first=++it;
      count-=step+1;
    }
    else count=step;
  }
  return first;
}

template <class ForwardIterator, class T>
  ForwardIterator upper_bound (ForwardIterator first, ForwardIterator last, const T& val)
{
  ForwardIterator it;
  iterator_traits<ForwardIterator>::difference_type count, step;
  count = std::distance(first,last);
  while (count>0)
  {
    it = first; step=count/2; std::advance (it,step);
    if (!(val<*it))                 // or: if (!comp(val,*it)), for version (2)
      { first=++it; count-=step+1;  }
    else count=step;
  }
  return first;
}
```



> 2023年2月17日

如何对字母组合、数字组合进行哈希？(e.g.: `[1,2,3], [1,3,2]`)

```c++
auto arrayHash = [fn = hash<int>{}] (const array<int, 26>& arr) -> size_t {
	return accumulate(
        arr.begin(), arr.end(), 0u, [&](size_t acc, int num) {
            return (acc << 1) ^ fn(num);
        });
};

作者：LeetCode-Solution
链接：https://leetcode.cn/problems/group-anagrams/solution/zi-mu-yi-wei-ci-fen-zu-by-leetcode-solut-gyoc/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



> 2023年2月15日

![image-20220823233042828]({{ site.url }}/imgs/leetcode/33.png)

二分查找，mid的两边总有一边是升序

二分查找的每个不等号都非常重要

> 2023年2月15日

![image-20220823233042828]({{ site.url }}/imgs/leetcode/32.png)

一维动态规划：

- 状态：dp[i]表示以第i个字符结尾的子串的最长有效括号长度
- 递推：
  - s[i] == '(', 则dp[i] = 0
  - s[i] == ')'
    - s[i - 1] == '(', 则dp[i] = dp[i - 2] + 2
    - s[i - 1] == ')', 需要找到s[i-1]结尾的最长有效括号子串左侧的字符，即s[i - 1 - dp[i - 1]]
      - s[i - 1 - dp[i - 1]] == '('，即和s[i]配对时，dp[i] = dp[i - 1] + 2 + dp[i - 1- dp[i - 1] - 1]，其中最后的一项是当前有效括号子串之前的最长有效括号子串的长度。
      - s[i - 1 - dp[i - 1]] == ')'，即s[i]不配对，dp[i] = 0

> 2023年2月14日

![image-20220823233042828]({{ site.url }}/imgs/leetcode/221.png)

动态规划如何找递推式?

- 尽量在时间复杂度较小的量级去找递推式
-  递推式实际上就是已知信息如何推出未知信息的过程

> 2023年2月14日

![image-20220823233042828]({{ site.url }}/imgs/leetcode/146.png)

1. 实现O(1)时间的访问：HashMap
2. 实现访问记录：利用双向链表（`std::list`）
   - 在访问时，将链表节点移动到链表尾部
   - 在容量已满时，将链表头部的元素删除
3. 实现HashMap与链表的对应：
   - 在HashMap的Item中存储链表的结点（`iterator`），访问HashMap时，移动存储的节点；
   - 在链表中存储HashMap的Key，链表容量满后，删除结点，并删除HashMap中对应的k-v对；

> 2022年8月23日

![image-20220823233042828]({{ site.url }}/imgs/leetcode/438.png)

子串问题：**滑动窗口**

字母异位词实际上就是每个字母出现频率相同的词，所以使用一个`vector`记录每个字母出现的频率来作为滑动窗口，在窗口滑动时，将相应的字符频率增加或减少。

```c++
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        int s_len = s.size(), p_len = p.size();
        if (s_len < p_len) return vector<int>();

        vector<int> res;
        vector<int> s_ch_freqs(26, 0);
        vector<int> p_ch_freqs(26, 0);

        for (int i = 0; i < p_len; ++i) {
            s_ch_freqs[s[i] - 'a']++;
            p_ch_freqs[p[i] - 'a']++;
        }

        if (s_ch_freqs == p_ch_freqs) res.push_back(0);

        for (int i = 0; i < s_len - p_len; ++i) {
            s_ch_freqs[s[i] - 'a']--;
            s_ch_freqs[s[i + p_len] - 'a']++;

            if (s_ch_freqs == p_ch_freqs) {
                res.push_back(i + 1);
            }
        }
        return res;
    }
};
```

> 2022年7月30日

![image-20220730140229033]({{ site.url }}\imgs\leetcode\169.png)

可以使用哈希表对数组元素的个数进行记录，然后再查询哈希表，找到多数元素，时间复杂度为 $O(n)$，空间复杂度 $O(n)$

```c++
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        unordered_map<int, int> num_freq;
        for (int i = 0; i < nums.size(); ++i) {
            if (num_freq.find(nums[i]) == num_freq.end()) {
                num_freq[nums[i]] = 1;
            } else {
                num_freq[nums[i]]++;
            }
        }
        for (auto& item : num_freq) {
            if (item.second > nums.size() / 2) return item.first;
        }
        return 0;
    }
};
```

记录一个Leetcode题解上面非常牛逼的算法：Boyer-Moore投票算法

- 维护一个候选众数`candidate`和它出现的次数`count`。初始时`candidate`可以为任意值`count`为 0；

- 遍历数组中的所有元素，对于每个元素 `x`，在判断 `x` 之前，如果 `count` 的值为 0，我们先将 `x`的值赋予 `candidate`，随后我们判断 `x`：

  - 如果 `x` 与 `candidate` 相等，那么计数器 `count` 的值增加 1；
  - 如果 `x` 与 `candidate`不等，那么计数器 `count` 的值减少 1；

- 在遍历完成后，`candidate` 即为整个数组的众数。


> 2022年7月29日

![image-20220730000321249]({{ site.url }}\imgs\leetcode\160.png)

最简单的方法：哈希表，遍历第一个链表，把地址都存入哈希表，然后再遍历第二个链表时查询哈希表。时间复杂度 $O(m+n)$ ，空间复杂度 $O(m)$。

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        unordered_set<ListNode*> nodes;
        ListNode *iter = headA;

        while (iter) {
            nodes.insert(iter);
            iter = iter->next;
        }
        iter = headB;
        while (iter) {
            if (nodes.find(iter) != nodes.end()) {
                return iter;
            }
            iter = iter->next;
        }
        return nullptr;
    }
};
```

题解上的一个非常妙的方法：

双指针，用两个指针分别遍历两个链表，然后：

- 如果两个指针地址相同，返回地址；
- 如果两个指针同时为空，返回`nullptr`；
- 如果A指针为空，B指针不为空，则将A指向B链表的起始节点；
- 如果B指针为空，A指针不为空，则将B指向A链表的起始节点；

正确性证明：

假设链表A到达相交点前有`a`个节点，链表B到达相交点前有`b`个节点，两链表相交的节点个数为`c`，则在双指针都到达相交点时遍历的节点数量相同，为`a+b+c`

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        if (!headA || !headB) return nullptr;
        if (headA == headB) return headA;
        ListNode* pa = headA;
        ListNode* pb = headB;
        while (pa != pb) {
            pa = pa ? pa->next : headB;
            pb = pb ? pb->next : headA;
        }
        return pa;
    }
};
```

> 2022年7月26日

![image-20220726191138265]({{ site.url }}\imgs\leetcode\108.png)

数据结构知识：

- 二叉搜索树：对于一棵二叉树，如果它的任意一个节点的左子树的所有节点的值都小于这个节点的值，且右子树的所有节点的值都大于这个节点的值，即为一棵二叉搜索树；
  - 二叉搜索树的中序遍历就是一个升序数列；
- 平衡二叉树：对于一颗二叉树，如果它的任意一个节点的左子树和右子树的深度之差小于2，则这棵树是一棵平衡二叉树；
  - 由数组构造平衡二叉树：逐个读取数组，并将下一个数字插入到当前树中，如果插入后的二叉树不平衡，则通过旋转将其变为平衡二叉树。（本题不需要）

本题根据二叉搜索树，即可确定做法：每次把数组的中间元素作为二叉树的根节点，即可建一棵平衡搜索树。

```c++
class Solution {
public:
    TreeNode* BuildTree(vector<int>& nums, int start, int end) {
        if (start >= end) return nullptr;
        int mid = start + (end - start) / 2;
        TreeNode* root = new TreeNode(nums[mid]);
        root->left = BuildTree(nums, start, mid);
        root->right = BuildTree(nums, mid + 1, end);
        return root;
    }

    TreeNode* sortedArrayToBST(vector<int>& nums) {
        return BuildTree(nums, 0, nums.size());
    }
};
```

> 2022年7月24日

![image-20220724231004899]({{ site.url }}\imgs\leetcode\101.png)

递归比较简单，从根节点分成两个子树，然后递归地比较两子树的左右子树是否相等即可：

```c++
class Solution {
public:
    bool CompareTwoTrees(TreeNode* tr1, TreeNode* tr2) {
        if (nullptr == tr1 && nullptr == tr2) return true;
        if (nullptr == tr1 || nullptr == tr2) return false;
        return (tr1->val == tr2->val) && CompareTwoTrees(tr1->left, tr2->right) && CompareTwoTrees(tr1->right, tr2->left);
    }

    bool isSymmetric(TreeNode* root) {
        if (nullptr == root->right && nullptr == root->left) return true;
        if (nullptr == root->right || nullptr == root->left) return false;
        TreeNode *left_half = root->left;
        TreeNode *right_half = root->right;
        return CompareTwoTrees(left_half, right_half);
    }
};
```

记录一个不太习惯的迭代法，其实就是用循环代替了递归，在每次循环开始进行递归要做的根节点比较，再在循环结束时利用**队列**准备好下次循环需要的数据：

```c++
class Solution {
public:
    bool CompareTwoTrees(TreeNode* tr1, TreeNode* tr2) {
        queue<TreeNode*> q;
        q.push(tr1);
        q.push(tr2);
        while (!q.empty()) {
            auto p1 = q.front();
            q.pop();
            auto p2 = q.front();
            q.pop();
            if (nullptr == p1 && nullptr == p2) continue;
            if (nullptr == p1 || nullptr == p2) return false;
            if (p1->val != p2->val) return false;

            q.push(p1->left);
            q.push(p2->right);
            q.push(p1->right);
            q.push(p2->left);
        }
        return true;
    }

    bool isSymmetric(TreeNode* root) {
        if (nullptr == root->right && nullptr == root->left) return true;
        if (nullptr == root->right || nullptr == root->left) return false;
        TreeNode *left_half = root->left;
        TreeNode *right_half = root->right;
        return CompareTwoTrees(left_half, right_half);
    }
};
```

> 2022年7月22日

![]({{ site.url }}\imgs\leetcode\69.png)

牛顿迭代法求解以下方程的根：
$$
f(x)=x^2-C
$$
迭代式为：
$$
x_{n+1} = x_{n}-\frac{f(x_n)}{f^{'}(x_n)} = x_n-\frac{x_n^2-C}{2x_n}=\frac{x_n+\frac{C}{x_n}}{2}
$$

```c++
class Solution {
public:
    int mySqrt(int x) {
        if (x == 0) return 0;
        if (x == 1) return 1;
        long long a = x;
        while (a > x / a) {
            a = (a + x / a) / 2;
        }
        return a;
    }
};
```







