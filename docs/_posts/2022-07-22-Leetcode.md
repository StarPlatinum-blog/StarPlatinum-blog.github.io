---
layout:	post
title:	LeetCode Record
date:   2022-07-22 10:21:00 +0800
categories: note
---

# LeetCode刷题记录

> 2022年7月26日

![image-20220726191138265]({{ site.url }}\imgs\leetcode\108.png)

数据结构知识：

- 二叉搜索树：对于一棵二叉树，如果它的任意一个节点的左子树的所有节点的值都小于这个节点的值，且右子树的所有节点的值都大于这个节点的值，即为一棵二叉搜索树；
  - 二叉搜索树的中序遍历就是一个升序数列；
- 平衡二叉树：对于一颗二叉树，如果它的任意一个节点的左子树和右子树的深度之差小于2，则这棵树是一棵平衡二叉树；
  - 由数组构造平衡二叉树：逐个读取数组，并将下一个数字插入到当前树中，如果插入后的二叉树不平衡，则通过旋转将其变为平衡二叉树。（本题不需要）

本题根据二叉搜索树，即可确定做法：每次把数组的中间元素作为二叉树的根节点，即可建一棵平衡搜索树。

```c++
class Solution {
public:
    TreeNode* BuildTree(vector<int>& nums, int start, int end) {
        if (start >= end) return nullptr;
        int mid = start + (end - start) / 2;
        TreeNode* root = new TreeNode(nums[mid]);
        root->left = BuildTree(nums, start, mid);
        root->right = BuildTree(nums, mid + 1, end);
        return root;
    }

    TreeNode* sortedArrayToBST(vector<int>& nums) {
        return BuildTree(nums, 0, nums.size());
    }
};
```

> 2022年7月24日

![image-20220724231004899]({{ site.url }}\imgs\leetcode\101.png)

递归比较简单，从根节点分成两个子树，然后递归地比较两子树的左右子树是否相等即可：

```c++
class Solution {
public:
    bool CompareTwoTrees(TreeNode* tr1, TreeNode* tr2) {
        if (nullptr == tr1 && nullptr == tr2) return true;
        if (nullptr == tr1 || nullptr == tr2) return false;
        return (tr1->val == tr2->val) && CompareTwoTrees(tr1->left, tr2->right) && CompareTwoTrees(tr1->right, tr2->left);
    }

    bool isSymmetric(TreeNode* root) {
        if (nullptr == root->right && nullptr == root->left) return true;
        if (nullptr == root->right || nullptr == root->left) return false;
        TreeNode *left_half = root->left;
        TreeNode *right_half = root->right;
        return CompareTwoTrees(left_half, right_half);
    }
};
```

记录一个不太习惯的迭代法，其实就是用循环代替了递归，在每次循环开始进行递归要做的根节点比较，再在循环结束时利用**队列**准备好下次循环需要的数据：

```c++
class Solution {
public:
    bool CompareTwoTrees(TreeNode* tr1, TreeNode* tr2) {
        queue<TreeNode*> q;
        q.push(tr1);
        q.push(tr2);
        while (!q.empty()) {
            auto p1 = q.front();
            q.pop();
            auto p2 = q.front();
            q.pop();
            if (nullptr == p1 && nullptr == p2) continue;
            if (nullptr == p1 || nullptr == p2) return false;
            if (p1->val != p2->val) return false;

            q.push(p1->left);
            q.push(p2->right);
            q.push(p1->right);
            q.push(p2->left);
        }
        return true;
    }

    bool isSymmetric(TreeNode* root) {
        if (nullptr == root->right && nullptr == root->left) return true;
        if (nullptr == root->right || nullptr == root->left) return false;
        TreeNode *left_half = root->left;
        TreeNode *right_half = root->right;
        return CompareTwoTrees(left_half, right_half);
    }
};
```

> 2022年7月22日

![]({{ site.url }}\imgs\leetcode\69.png)

牛顿迭代法求解以下方程的根：
$$
f(x)=x^2-C
$$
迭代式为：
$$
x_{n+1} = x_{n}-\frac{f(x_n)}{f^{'}(x_n)} = x_n-\frac{x_n^2-C}{2x_n}=\frac{x_n+\frac{C}{x_n}}{2}
$$

```c++
class Solution {
public:
    int mySqrt(int x) {
        if (x == 0) return 0;
        if (x == 1) return 1;
        long long a = x;
        while (a > x / a) {
            a = (a + x / a) / 2;
        }
        return a;
    }
};
```







