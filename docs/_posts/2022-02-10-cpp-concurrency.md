---
layout:	post
title:	C++ Concurrency
date:   2022-02-10 11:27:12 +0800
categories: note 
---

# C++ 并发编程

## 1. 线程管控

### 1.1 基本线程管控

#### 1.1.1 发起线程

#### 1.1.2 等待线程完成

#### 1.1.3 出现异常的情况下等待

#### 1.1.4 在后台运行线程

### 1.2 向线程传递参数

### 1.3 移交线程归属权

### 1.4 在运行时选择线程数量

### 1.5 识别线程



## 2. 在线程间共享数据

### 2.1 线程间共享数据的问题

不变量：针对某一特定数据的断言，需要保持为真实值的一个量。例如链表元素的个数就是一个不变量。

#### 2.1.1 条件竞争

`定义`：在并发编程中，操作由两个或多个线程负责，他们争先让线程执行各自的操作，而结果取决于它们执行的次序。

良性条件竞争：即使改变的线程的执行次序，结果也能够被接收；

恶性条件竞争：典型场景：完成一项操作需要改动两份或多份数据。

#### 2.1.2 防止恶性条件竞争

方法：

1. 不变量加锁：采取保护措施包装数据结构，确保不变量被破坏时，中间状态只对执行改动的线程可见。

2. 无锁编程：修改数据结构设计及其不变量，由一连串不可拆分的改动完成数据变更，每个改动都维持不变量不被破坏。无锁编程较为复杂，需要了解内存模型和线程可以看到的数据集。

3. 将修改数据结构当作事务（transaction）来处理。软件事务内存（Software Transaction Memory）

   类似于数据库在一个事务内完成更新：把需要执行的数据读写任务视为一个完整的序列，先用事务日志存储记录，再把序列当成单一步骤提交执行。

   若别的线程改动了数据，导致提交无法完整执行，则事务重新开始。

### 2.2 用互斥保护共享数据

互斥（mutex: mutual exclusion）：标记访问受保护数据结构的代码，令各线程在其上相互排斥，只要由线程在运行标记的代码，任何别的线程想要访问同一块数据就必须等待。

#### 2.2.1 在C++中使用互斥

在c++中使用`std::mutex`类来创建互斥，调用成员函数`lock`来对代码加锁，调用`unlock`来解锁：

```c++
#include <mutex>
#include <list>
std::list<int> some_list;
std::mutex some_mutex;

int AddToList(int value) {
    some_mutex.lock();			// 加锁
    some_list.push_back(value);	// 操作链表
    some_mutex.unlock();		// 解锁
}
```

这样就必须在函数以外的每条代码路径上都调用`unlock`（如果有分支），包括异常处理中。取而代之，C++提供了类模板`std::lock_guard<>`，使用RAII来进行加锁解锁：构造时加锁，析构时解锁，从而保证互斥被正确解锁：

```c++
int AddToList(int value) {
    std::lock_guard<std::mutex> guard(some_mutex);	// 构造lock_guard，加锁
    some_list.push_back(value);						// 操作链表
}	// guard析构，解锁
```

一般互斥和受保护的数据会一起组成一个类，





#### 2.2.2 组织和编排代码以保护共享数据

#### 2.2.3 发现接口固有的条件竞争

#### 2.2.4 死锁：问题和解决方法

#### 2.2.5 防范死锁的补充准则

#### 2.2.6 运用std::unique_ptr<>灵活加锁

#### 2.2.7 在不同作用域之间转移互斥归属权

#### 2.2.8 按适合的粒度加锁

### 2.3 保护共享数据的其他工具

#### 2.3.1 在初始化过程中保护共享数据

#### 2.3.2 保护较少更新的数据结构

#### 2.3.3 递归加锁

