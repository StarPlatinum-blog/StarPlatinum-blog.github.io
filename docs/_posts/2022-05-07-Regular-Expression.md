---
layout:	post
title:	Regular Expression
date:   2022-05-07 22:02:00 +0800
categories: note
---

[TOC]

<head>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    </script>
</head>

# Regular Expression

[Python re](https://docs.python.org/3/library/re.html)文档翻译。

## 1. Regular Expression Syntax

正则表达式（RE: Regular Expression）指定一组与其匹配的字符串；这个模块中的函数让你检查一个特定的字符串是否匹配一个给定的正则表达式（或者一个给定的正则表达式是否匹配一个特定的字符串，这归结为同一件事）。

正则表达式可以串联起来形成新的正则表达式；如果 A 和 B 都是正则表达式，那么 AB 也是正则表达式。一般来说，如果一个字符串 p 匹配 A，另一个字符串 q 匹配 B，则字符串 pq 将匹配 AB。除非 A 或 B 包含低优先级操作、存在 A 和 B 之间的边界条件或有编号的组参考。因此，复杂的表达式可以很容易地从更简单的原始表达式构造出来。有关正则表达式的理论和实现的详细信息，请参阅 Friedl 的书 [Frie09](https://docs.python.org/3/library/re.html#frie09)，或几乎任何有关编译器构造的教科书。

下面简要说明正则表达式的格式。

1. 正则表达式可以包含特殊字符和普通字符。大多数普通字符，如“A”、“a”或“0”，都是最简单的正则表达式；他们只是匹配自己。您可以连接普通字符，因此 last 匹配字符串 'last'。 

2. 一些字符，例如“|”或 '(' 是特殊的。特殊字符要么代表普通字符的类别，要么影响它们周围的正则表达式的解释方式。

3. 重复限定符（`*、+、?、{m,n}` 等）不能直接嵌套。这避免了与非贪婪修饰符后缀 `?` 以及其他实现中的其他修饰符的歧义。要将第二个重复限定应用于内部重复重复限定，可以使用括号。例如，表达式 `(?:a{6})*` 匹配六个“a”字符的任意倍数。

特殊字符包括：

- `.`

  在默认模式下，匹配除换行符以外的任何字符。 如果已指定 [`DOTALL`](https://docs.python.org/3/library/re.html#re.DOTALL) 标志，则匹配任何字符，包括换行符。

- `^`

  匹配字符串的开头，在 [`MULTILINE`](https://docs.python.org/3/library/re.html#re.MULTILINE) 模式下也会在每个换行符之后立即匹配。

- `$`

  匹配字符串的结尾或字符串末尾的换行符之前，并且在 MULTILINE 模式下匹配换行符之前。 `foo` 匹配'foo'和'foobar'，而 `foo$` 只匹配'foo'。 在 'foo1\nfoo2\n' 中搜索 `foo.$` 通常匹配 'foo2'，但在 MULTILINE 模式下匹配 'foo1'； 在 'foo\n' 中搜索单个 `$` 将找到两个（空）匹配项：一个在换行符之前，一个在字符串末尾。

- `*`

  使生成的 RE 匹配前一个 RE 的 0 次或多次重复，尽可能多的重复。 `ab*` 将匹配“a”、“ab”或“a”后跟任意数量的“b”。

- `+`

  使生成的 RE 匹配前一个 RE 的 1 次或多次重复。 `ab+` 将匹配‘a’后跟任意非零数量的‘b’； 它不会只匹配“a”。

- `?`

  使生成的 RE 匹配前面 RE 的 0 或 1 次重复。 `ab?` 将匹配`'a'`或`'ab'`。

- `*?`, `+?`, `??`

  `'\*'`、`'+'` 和 `'?'` 限定符都是*贪婪*的； 它们匹配尽可能多的文本。 有时这种行为是不需要的； 如果 RE `<.*>` 与 `'<a> b <c>'` 匹配，它将匹配整个字符串，而不仅仅是 `'<a>'`。 在限定符后添加 ? 使其以非贪婪或最低限度的方式执行匹配，将匹配**尽可能少**的字符。 使用 RE `<.*?>` 将仅匹配 `'<a>'`。

- `{m}`

  指定恰好匹配前一个 RE 的 m 个字符； 少于m个匹配的字符会导致整个 RE 不匹配。 例如，`a{6}` 将精确匹配 `'aaaaaa'` 字符，但`'aaaa'`就不能匹配。

- `{m,n}`

  使生成的 RE 匹配前一个 RE 的 m 到 n 个重复，尝试匹配尽可能多的重复。 例如，`a{3,5}` 将匹配 3 到 5 个“a”字符。 省略 m 指定下限为零，省略 n 指定无限上限。 例如，`a{4,}b` 将匹配 `'aaaab'` 或一千个 `'a'` 字符后跟一个 `'b'`，但不匹配 `'aaab'`。 逗号不能省略，否则修饰符会与前面描述的形式混淆。

- `{m,n}?`

  使生成的 RE 匹配前一个 RE 的 m 到 n 个重复，尝试匹配尽可能少的重复。 这是上一个限定符的非贪婪版本。 例如，在 6 个字符的字符串 `'aaaaaa'` 上，`a{3,5}` 将匹配 5 个 `'a'` 字符，而 `a{3,5}?` 只会匹配 3 个字符。

- `\`

  要么转义特殊字符（允许您匹配`'*'`、`'?'`等字符），要么表示特殊序列； 特殊序列将在下文讨论。

  如果您不使用原始字符串（例如`r"hello"`）来表达模式，请记住 Python 还使用反斜杠作为字符串文字中的转义序列； 如果 Python 的解析器无法识别转义序列，则反斜杠和后续字符将包含在结果字符串中。 但是，如果 Python 能够识别结果序列，则**反斜杠应该重复两次**。 这很复杂且难以理解，因此强烈建议您对**除最简单的表达式之外的所有表达式都使用原始字符串**。

- `[]`

  用于表示一组字符，对单个字符进行匹配。在一组中：

  - 字符可以单独列出，例如`[amk]`将匹配`"a"`、`"m"`或`"k"`。

  - **字符范围可以通过给出两个字符并用`-`分隔它们来表示**，例如`[a-z]`将匹配任何小写ASCII字母，`[0-5][0-9]`将匹配所有两位数字00 到 59，并且`[0-9A-Fa-f]`将匹配任何十六进制数字。如果 `-` 被转义（例如 `[a\-z]`）或者如果它被放置为第一个或最后一个字符（例如 `[-a]` 或 `[a-]`），它将匹配一个字符 `-`。

  - 特殊字符在集合中**失去其特殊含义**。例如，`[(+*)]` 将匹配任何文字字符 `'('`、`'+'`、`'\*'` 或 `')'`。

  - 在集合中也接受诸如 `\w` 或 `\S`（下文将进行定义）之类的字符类，尽管它们匹配的字符取决于 ASCII 或 LOCALE 模式是否有效。

  - 不在一个范围内的字符可以通过补集来匹配。如果集合的第一个字符是`^`，那么所有不在集合中的字符都将被匹配。例如，`[^5]` 将匹配除 `'5'` 之外的任何字符，而 `[^^]` 将匹配除 `'^'` 之外的任何字符。**如果 ^ 不是集合中的第一个字符，则 ^ 没有特殊含义。**

  - 要匹配集合内的字符 `']'`，请在其前面加上**反斜杠**，或将其放在集合的开头。例如，`[()[\]{}]` 和 `[]()[{}]` 都将匹配括号。

  - 将来可能会添加对 Unicode Technical Standard #18 中嵌套集合和集合操作的支持。这将改变语法，因此为了促进这种改变，FutureWarning 将暂时在模棱两可的情况下引发。这包括以文字“[”开头或包含文字字符序列`"--"`、`"&&"`、`"~~"`和`"||"`的集合。为了避免警告，用反斜杠转义它们。

- `|`

  `A|B`，其中 A 和 B 可以是任意 RE，创建将匹配 **A 或 B** 的正则表达式。任意数量的 RE 可以用`|`分隔。 这也可以在**组**内使用（见下文）。 扫描目标字符串时，REs 由 `|` 分隔，从左到右尝试。 当一个模式完全匹配时，该分支被接受。 这意味着一旦 A 匹配，B 将不会被进一步测试，**即使它会产生更长的整体匹配**。 换句话说，`|` 操作符从不贪婪。 要匹配字符`|`，请使用 `\|`，或将其括在字符类中，如 `[|]`。

- `(...)`

  匹配括号内的任何正则表达式，并指示组的开始和结束； 组的内容可以在执行匹配后检索，并且可以稍后在字符串中使用 `\number` 特殊序列进行匹配，如下所述。 要匹配字符 `'('` 或 `')'`，请使用 `\(` 或 `\)`，或将它们包含在字符类中：`[(]`, `[)]`。

- `(?...)`

  这是一个扩展符号（`'('` 后面的 `'?'` 没有意义）。`'?'` 之后的第一个字符决定了构造的含义和进一步的语法是什么。扩展通常不会创建新**组**；`(?P<name>...)` 是该规则的唯一例外。以下是当前支持的扩展。

- `(?aiLmsux)`

  （来自集合`'a'`、`'i'`、`'L'`、`'m'`、`'s'`、`'u'`、`'x'`的一个或多个字母。）组匹配空字符串； 这些字母设置了相应的标志：`re.A`（仅 ASCII 匹配）、`re.I`（忽略大小写）、`re.L`（取决于语言环境）、`re.M`（多行）、`re.S`（`.`匹配所有字符） 、`re.U`（Unicode 匹配）和 `re.X`（详细），用于整个正则表达式。 （标志在 [Module Contents](https://docs.python.org/3/library/re.html#contents-of-module-re)中描述。）如果您希望将标志包含在正则表达式中，而不是将标志参数传递给 re.compile() 函数，这将很有用。 标志应首先在表达式字符串中使用。

- `(?:...)`

  常规括号的非捕获版本。 匹配括号内的任何正则表达式，但组匹配的子字符串在执行匹配后无法检索或稍后在模式中引用。

- `(?aiLmsux-imsx:...)`

  （`'a'`、`'i'`、`'L'`、`'m'`、`'s'`、`'u'`、`'x'` 集合中的零个或多个字母，可以在后面添加`'-'` 后跟一个或多个来自`'i'`, `'m'`, `'s'`, `'x'`的字符) 。这些字母设置或删除相应的标志。

  字母`“a”`、`“L”`和`“u”`在用作**内联标志**时是互斥的，因此它们不能组合或跟随`“-”`。相反，当其中一个出现在内联组中时，它会覆盖封闭组中的匹配模式。在 Unicode 模式中 `(?a:...) `切换到仅 ASCII 匹配，并且 `(?u:...) `切换到 Unicode 匹配（默认）。在字节模式中 `(?L:...) `切换到取决于匹配的区域设置，并且 `(?a:...) `切换到仅 ASCII 匹配（默认）。此覆盖仅对窄内联组有效，并且在组外恢复原始匹配模式。

- `(?P<name>...)`

  类似于常规括号，但组匹配的子字符串可通过符号组名称访问。 组名必须是有效的 Python 标识符，并且每个组名只能在正则表达式中定义一次。 符号组也是一个编号组，就好像该组没有命名一样。

  可以在三种上下文中引用命名组。 如果模式是 `(?P<quote>['"]).*?(?P=quote) `（即匹配用单引号或双引号引起来的字符串）：

  | 对于"quote"组的引用内容                  | 引用它的方式                             |
  | ---------------------------------------- | ---------------------------------------- |
  | 在同一个匹配模式中                       | `(?P=quote)`（如上面表示的一样 ）或 `\1` |
  | 处理匹配对象`m`时                        | `m.group('quote')` `m.end('quote')`      |
  | 在传递给 re.sub() 的 repl 参数的字符串中 | `\g<quote>` `\g<1>` `\1`                 |

- `(?P=name)`

  对命名组的后半引用； 它匹配与早先名为 name 的组匹配的任何文本。

- `(?#...)`

  一条注释，括号的内容将被忽略。

- `(?=...)`

  如果`...`在前面的模式后能够匹配，整个RE才能匹配，同时不接收`...`中的任何字符。 这称为*前瞻断言*。 例如，`Isaac_(?=Asimov)` 仅在 `'Isaac_'` 后跟 `'Asimov'` 时才会匹配`Isaac_`。

- `(?!...)`

  与上面相反，如果`...`在前面的模式后不能匹配，整个RE才能匹配。这是一个*否定前瞻断言*。 例如，`Isaac_(?!Asimov) `，仅当它后面没有 `'Asimov'` 时，才匹配 `'Isaac_'` 。

- `(?<=...)`

  如果字符串中的当前位置前面有一个在当前位置结束的 `...` 匹配，则整个模式才能匹配。 这称为*肯定后向断言*。 `(?<=abc)def `将在 `'abcdef'` 中找到匹配项，因为后视将备份 3 个字符并检查包含的模式是否匹配。 包含的模式必须只匹配一些固定长度的字符串，这意味着 `abc` 或 `a|b` 是允许的，但 `a*` 和 `a{3,4}` 是不允许的。 请注意，以肯定后向断言开头的模式在被搜索的字符串的开头不会匹配； 您很可能希望使用 search() 函数而不是 match() 函数：

  ```python
  >>> import re
  >>> m = re.search('(?<=abc)def', 'abcdef')
  >>> m.group(0)
  'def'
  ```

  此示例查找连字符后的单词：

  ```python
  >>> m = re.search(r'(?<=-)\w+', 'spam-egg')
  >>> m.group(0)
  'egg'
  ```

- `(?<!...)`

  如果字符串中的当前位置前面没有匹配`...`，则匹配。这称为*否定后向断言*。 与肯定的后向断言类似，包含的模式必须只匹配一些固定长度的字符串。 以否定后向断言开头的模式可能在被搜索的字符串的开头匹配。

- `(?(id/name)yes-pattern|no-pattern)`

  如果具有给定 id 或名称的组存在，将尝试与 `yes-pattern` 匹配，如果不存在，则尝试与 `no-pattern` 匹配。 `no-pattern` 是可选的，可以省略。 例如，`(<)?(\w+@\w+(?:\.\w+)+)(?(1)>|$)` 是一个电子邮件匹配模式，它将与 `'<user@host.com >'`和` 'user@host.com'`匹配，但不包括 `'<user@host.com' `和 `'user@host.com>'`匹配。